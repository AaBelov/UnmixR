N-FINDR-CB
========================================================

Idea for improved N-FINDR.

- simplex volume = factor (p) * (hyper)area of base of p points * height of (p + 1)th corner point.

- when iterating over the (nrow - p) candidates for a simplex corner, do "Hauptachsentransformation"  to align p base points along the first p - 1 dimensions. SVD (PCA) gives this rotation (up to a translationaalong the pth dimension).
- The score along the pth dimension then gives the height of the last corner point. 
  => choose point with largest distance to the base points.

```{r}
n <- 10
p <- 2
data <- matrix (runif (p*n), n)
i.simplexbase <- 1 : p

.typ <- function (n, ibase = FALSE, imax = FALSE){
	typ <- rep (1, n)
	typ [ibase] <- 2
	typ [imax] <- 3
	
	typ
	}
	
center <- function (x, center = TRUE){
	if (isTRUE (center))
		center <- colMeans (x)
		
	x - rep (center, each = nrow (x))
}

pause <- function () {
    if(interactive()) readline("Pause. Press <Enter> to continue...")
    invisible()
    }
```


```{r plotdata, fig.width=7, fig.height=6}
plot(data, xlim = c (-1.5, 1.5), ylim = c (-1.5, 1.5), asp = 1,
		 pch = c (1, 19, 20) [.typ (n, i.simplexbase)],
		 col = .typ (n, i.simplexbase))
```

```{r svd}
rot <- svd (center (data [i.simplexbase,]))$v
prot <- data %*% rot
```
```{r plotrot, fig.width=7, fig.height=7}
<<plotdata>>
points(prot, xlim = c (-1.5, 1.5), ylim = c (-1.5, 1.5), asp = 1, cex = 0.5,
		 pch = c (1, 19, 20) [.typ (n, i.simplexbase)],
		 col = .typ (n, i.simplexbase))
```


Distances between the points do not change:
```{r checkrot}
summary (dist (prot) - dist (data))
```
Check base points have same pth score:
```{r checkz}
z.base <- prot [i.simplexbase [1], p]
summary (prot [i.simplexbase, p] - z.base)
```
get max abs z

```{r maxz, fig.width=7, fig.height=7}
<<plotrot>>
i.max <- which.max (abs (prot [, p] - z.base))
points (prot [i.max,1], prot [i.max,2], pch = 19, col = 3, cex = 0.5)
points (data [i.max,1], data [i.max,2], pch = 19, col = 3)
```
Put together:

```{r nfindrcb}
maxcorner <- function (points, i.simplexbase) {
	rot <- svd (center (points [i.simplexbase,]))$v
	points <- points %*% rot
	z.base <- points [i.simplexbase [1], p]
	which.max (abs (points [, p] - z.base))
}

nfindr.cb <- function (data, i.simplex = sample (nrow (data), p + 1)){
 	p <- ncol (data)
	# plot (data, asp = 1)

	old.simplex <- i.simplex
	
	# points (data [i.simplex, ], pch = 19, col = 2)

	for (iter in 1 : (3 * (p + 1))) { # combine the two loops into one. 
		
	  i.change <- 1 + iter %% (p + 1)
	  
		i.simplex [i.change] <- maxcorner (data, i.simplex [- i.change])
		
	  #text (data [i.simplex [i.change],, drop = FALSE], label = sprintf ("   %i", iter))
		
	  if (iter > p) { # all points optimized at least once: from now on, if the point didn't change, 
	  	              # we're at the solution.
			if (all (i.simplex == old.simplex))
				break
			else
			  old.simplex <- i.simplex
		}
	}
	
	i.simplex
}
```

```{r testrun}
(endmembers <- nfindr.cb (data))
plot (data, asp = 1)
points (data [endmembers,], pch = 19)
```